import requests
import json
import time
import os
from urllib.parse import urlencode

class TranslationAPIClient:
    def __init__(self, base_url="http://127.0.0.1:8000"):
        self.base_url = base_url
        self.access_token = None
        self.refresh_token = None
        self.client_key = "2852de38650241abb839e5a04a6014bd"
    
    def get_headers(self, include_auth=True):
        """Retourne les en-t√™tes avec ou sans authentification JWT"""
        headers = {
            "Content-Type": "application/json",
            "X-Client-Key": self.client_key
        }
        
        if include_auth and self.access_token:
            headers["Authorization"] = f"Bearer {self.access_token}"
        
        return headers
    
    def get_file_headers(self, include_auth=True):
        """Headers pour l'upload de fichiers (sans Content-Type)"""
        headers = {
            "X-Client-Key": self.client_key
        }
        
        if include_auth and self.access_token:
            headers["Authorization"] = f"Bearer {self.access_token}"
        
        return headers
    
    # ==================== AUTHENTIFICATION ====================
    
    def register_user(self, username, email, password, password_confirm=None, first_name=None, last_name=None):
        """Inscription d'un nouvel utilisateur"""
        url = f"{self.base_url}/api/auth/register/"
        data = {
            "username": username,
            "email": email,
            "password": password,
            "password_confirm": password_confirm or password,
            "first_name": first_name,
            "last_name": last_name
        }
        
        return self._make_request('POST', url, data, include_auth=False, operation="Inscription")
    
    def login(self, email, password):
        """Connexion et r√©cup√©ration des tokens JWT"""
        url = f"{self.base_url}/api/auth/token/"
        data = {
            "email": email,
            "password": password
        }
        
        try:
            response = requests.post(url, headers=self.get_headers(include_auth=False), json=data)
            response.raise_for_status()
            
            response_data = response.json()
            tokens = response_data.get('data', {})
            self.access_token = tokens.get('access')
            self.refresh_token = tokens.get('refresh')
            
            print("‚úÖ Connexion r√©ussie!")
            print("üìã R√©ponse compl√®te:", json.dumps(response_data, indent=2, ensure_ascii=False))
            
            if self.access_token:
                print(f"üîë Token d'acc√®s re√ßu: {self.access_token[:50]}...")
            if self.refresh_token:
                print(f"üîÑ Token de rafra√Æchissement re√ßu: {self.refresh_token[:50]}...")
            
            return response_data
            
        except requests.exceptions.RequestException as e:
            print("‚ùå Erreur connexion:", e)
            return None
    
    def refresh_access_token(self):
        """Rafra√Æchit le token d'acc√®s"""
        if not self.refresh_token:
            print("‚ùå Aucun refresh token disponible")
            return False
        
        url = f"{self.base_url}/api/auth/token/refresh/"
        data = {"refresh": self.refresh_token}
        
        try:
            response = requests.post(url, headers=self.get_headers(include_auth=False), json=data)
            response.raise_for_status()
            
            response_data = response.json()
            tokens = response_data.get('data', {})
            self.access_token = tokens.get('access')
            
            print("‚úÖ Token rafra√Æchi avec succ√®s!")
            return True
            
        except requests.exceptions.RequestException as e:
            print("‚ùå Erreur refresh token:", e)
            return False
    
    def get_profile(self):
        """R√©cup√®re le profil utilisateur"""
        return self._make_authenticated_request('GET', '/api/auth/profile/', operation="Profil utilisateur")
    
    # ==================== GESTION DES FICHIERS ====================
    
    def get_files(self, **params):
        """
        Liste des fichiers avec filtres
        Param√®tres support√©s: page, page_size, status, file_type, filename,
        uploaded_after, uploaded_before, file_size_min, file_size_max,
        framework, has_strings, search, ordering
        """
        url = f"{self.base_url}/api/files/files/"
        if params:
            url += f"?{urlencode(params)}"
        
        return self._make_authenticated_request('GET', url, operation="Liste des fichiers")
    
    def upload_file(self, file_path):
        """Upload d'un fichier de traduction - VERSION CORRIG√âE"""
        url = f"{self.base_url}/api/files/files/"
        
        if not os.path.exists(file_path):
            print(f"‚ùå Fichier non trouv√©: {file_path}")
            return None
        
        try:
            with open(file_path, 'rb') as f:
                files = {'file': f}
                headers = self.get_file_headers(include_auth=True)
                
                print(f"üì§ Upload du fichier: {file_path}")
                print(f"üìä Taille du fichier: {os.path.getsize(file_path)} bytes")
                
                response = requests.post(url, headers=headers, files=files)
                
                # Debug: Afficher le statut et le contenu brut
                print(f"üîç Status Code: {response.status_code}")
                print(f"üîç Response Headers: {dict(response.headers)}")
                print(f"üîç Response Content: {response.text}")
                
                response.raise_for_status()
                
                # G√©rer les r√©ponses vides ou non-JSON
                result = None
                if response.content.strip():
                    try:
                        result = response.json()
                    except json.JSONDecodeError:
                        print("‚ö†Ô∏è R√©ponse non-JSON re√ßue")
                        result = {"status": "uploaded", "message": "Upload r√©ussi", "raw_response": response.text}
                else:
                    print("‚ö†Ô∏è R√©ponse vide re√ßue")
                    result = {"status": "uploaded", "message": "Upload r√©ussi (r√©ponse vide)"}
                
                print("‚úÖ Upload r√©ussi!")
                if result:
                    print("üìã R√©ponse:", json.dumps(result, indent=2, ensure_ascii=False))
                
                return result
                
        except requests.exceptions.RequestException as e:
            print("‚ùå Erreur upload:", e)
            if hasattr(e, 'response') and e.response is not None:
                self._print_error_details(e.response)
            return None
    
    def get_file_details(self, file_id):
        """D√©tails d'un fichier sp√©cifique"""
        url = f"{self.base_url}/api/files/files/{file_id}/"
        return self._make_authenticated_request('GET', url, operation=f"D√©tails fichier {file_id}")
    
    def get_file_progress(self, file_id):
        """Progr√®s de traitement d'un fichier"""
        url = f"{self.base_url}/api/files/files/{file_id}/progress/"
        return self._make_authenticated_request('GET', url, operation=f"Progr√®s fichier {file_id}")
    
    def get_file_download_url(self, file_id):
        """Lien de t√©l√©chargement d'un fichier"""
        url = f"{self.base_url}/api/files/files/{file_id}/download/"
        return self._make_authenticated_request('GET', url, operation=f"Download URL fichier {file_id}")
    
    def get_files_statistics(self):
        """Statistiques globales des fichiers"""
        url = f"{self.base_url}/api/files/files/statistics/"
        return self._make_authenticated_request('GET', url, operation="Statistiques des fichiers")
    
    # ==================== GESTION DES CHA√éNES ====================
    
    def get_strings(self, **params):
        """
        Liste des cha√Ænes de traduction avec filtres
        Param√®tres: page, page_size, file, file_name, file_type, key,
        source_text, context, is_translated, is_fuzzy, is_plural,
        line_number, line_number_min, line_number_max, has_translations,
        search, ordering
        """
        url = f"{self.base_url}/api/files/strings/"
        if params:
            url += f"?{urlencode(params)}"
        
        return self._make_authenticated_request('GET', url, operation="Liste des cha√Ænes")
    
    def get_string_details(self, string_id):
        """D√©tails d'une cha√Æne sp√©cifique"""
        url = f"{self.base_url}/api/files/strings/{string_id}/"
        return self._make_authenticated_request('GET', url, operation=f"D√©tails cha√Æne {string_id}")
    
    def get_strings_by_file(self, file_id, **params):
        """Cha√Ænes d'un fichier sp√©cifique"""
        params['file_id'] = file_id
        url = f"{self.base_url}/api/files/strings/by_file/?{urlencode(params)}"
        return self._make_authenticated_request('GET', url, operation=f"Cha√Ænes du fichier {file_id}")
    
    def get_strings_statistics(self):
        """Statistiques globales des cha√Ænes"""
        url = f"{self.base_url}/api/files/strings/statistics/"
        return self._make_authenticated_request('GET', url, operation="Statistiques des cha√Ænes")
    
    # ==================== M√âTHODES UTILITAIRES ====================
    
    def monitor_file_progress(self, file_id, max_attempts=30, interval=2):
        """Surveille le progr√®s de traitement d'un fichier"""
        print(f"üîÑ Surveillance du progr√®s pour le fichier {file_id}...")
        
        for attempt in range(max_attempts):
            progress_data = self.get_file_progress(file_id)
            
            if not progress_data:
                print("‚ùå Impossible de r√©cup√©rer le progr√®s")
                return False
            
            status = progress_data.get('status')
            progress = progress_data.get('progress', 0)
            
            print(f"üìä Tentative {attempt + 1}: Status={status}, Progr√®s={progress}%")
            
            if status == 'completed':
                print("‚úÖ Traitement termin√©!")
                return True
            elif status == 'error':
                print(f"‚ùå Erreur de traitement: {progress_data.get('error', 'Erreur inconnue')}")
                return False
            
            time.sleep(interval)
        
        print("‚è∞ Timeout: Surveillance interrompue")
        return False
    
    def _make_authenticated_request(self, method, url, data=None, operation="Requ√™te"):
        """Effectue une requ√™te authentifi√©e avec gestion du refresh token"""
        if not self.access_token:
            print("‚ùå Aucun token d'acc√®s. Veuillez vous connecter d'abord.")
            return None
        
        # Si l'URL ne commence pas par http, l'ajouter
        if not url.startswith('http'):
            if url.startswith('/'):
                url = f"{self.base_url}{url}"
            else:
                url = f"{self.base_url}/{url}"
        
        headers = self.get_headers(include_auth=True)
        
        try:
            response = self._execute_request(method, url, headers, data)
            
            # Si le token a expir√© (401), essayer de le rafra√Æchir
            if response.status_code == 401:
                print("üîÑ Token expir√©, tentative de rafra√Æchissement...")
                if self.refresh_access_token():
                    headers = self.get_headers(include_auth=True)
                    response = self._execute_request(method, url, headers, data)
            
            response.raise_for_status()
            
            # Gestion des r√©ponses vides (DELETE 204)
            if response.status_code == 204:
                print(f"‚úÖ {operation} r√©ussi(e) (204 No Content)")
                return {"status": "success", "message": "Op√©ration r√©ussie"}
            
            result = response.json() if response.content else None
            print(f"‚úÖ {operation} r√©ussi(e)!")
            return result
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Erreur {operation}:", e)
            if hasattr(e, 'response') and e.response is not None:
                self._print_error_details(e.response)
            return None
    
    def _execute_request(self, method, url, headers, data):
        """Ex√©cute la requ√™te HTTP selon la m√©thode"""
        if method.upper() == 'GET':
            return requests.get(url, headers=headers)
        elif method.upper() == 'POST':
            return requests.post(url, headers=headers, json=data)
        elif method.upper() == 'PUT':
            return requests.put(url, headers=headers, json=data)
        elif method.upper() == 'DELETE':
            return requests.delete(url, headers=headers)
        else:
            raise ValueError(f"M√©thode HTTP non support√©e: {method}")
    
    def _make_request(self, method, url, data=None, include_auth=True, operation="Requ√™te"):
        """M√©thode g√©n√©rique pour les requ√™tes"""
        try:
            headers = self.get_headers(include_auth=include_auth)
            response = self._execute_request(method, url, headers, data)
            response.raise_for_status()
            
            result = response.json() if response.content else None
            print(f"‚úÖ {operation} r√©ussi(e)!")
            if result:
                print("üìã R√©ponse:", json.dumps(result, indent=2, ensure_ascii=False))
            return result
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Erreur {operation}:", e)
            if hasattr(e, 'response') and e.response is not None:
                self._print_error_details(e.response)
            return None
    
    def _print_error_details(self, response):
        """Affiche les d√©tails d'erreur de la r√©ponse"""
        try:
            error_details = response.json()
            print("üìã D√©tails de l'erreur:", json.dumps(error_details, indent=2, ensure_ascii=False))
        except Exception:
            print("La r√©ponse d'erreur n'est pas en JSON ou est vide.")
            print(f"Statut: {response.status_code}")
            print(f"Contenu: {response.text}")

# ==================== TEST AVEC DJANGO_TRANSLATION.PO - VERSION CORRIG√âE ====================

def test_django_translation():
    """Test avec le fichier django_translation.po sp√©cifique - VERSION CORRIG√âE"""
    client = TranslationAPIClient()
    
    # Chemin fixe du fichier
    django_po_path = "/home/billa/T√©l√©chargements/django_translation.po"
    
    # Donn√©es utilisateur pour les tests
    user_data = {
        "username": "o_tesdddstDDer_2025",
        "email": "d_tcesddtdceddr@exDDample.com",
        "password": "DjangoTest123!",
        "password_confirm": "DjangoTest123!",
        "first_name": "Django",
        "last_name": "Tester"
    }
    
    print("=" * 70)
    print("üöÄ TEST AVEC DJANGO_TRANSLATION.PO - VERSION CORRIG√âE")
    print("=" * 70)
    
    # 1. V√©rifier que le fichier existe
    if not os.path.exists(django_po_path):
        print(f"‚ùå Fichier non trouv√©: {django_po_path}")
        print("üí° V√©rifiez que le fichier existe dans le r√©pertoire sp√©cifi√©")
        return
    
    print(f"‚úÖ Fichier trouv√©: {django_po_path}")
    print(f"üìä Taille du fichier: {os.path.getsize(django_po_path)} bytes")
    
    # 2. Inscription (optionnelle si l'utilisateur existe d√©j√†)
    print("\n1Ô∏è‚É£ === INSCRIPTION UTILISATEUR ===")
    registration_result = client.register_user(**user_data)
    if registration_result:
        print("‚úÖ Inscription r√©ussie!")
    else:
        print("‚ö†Ô∏è Inscription √©chou√©e (utilisateur existe peut-√™tre d√©j√†)")
    
    # 3. Connexion
    print("\n2Ô∏è‚É£ === CONNEXION ===")
    login_result = client.login("Billa1818@gmail.com","1234")
    if not login_result:
        print("‚ùå Impossible de se connecter. Test interrompu.")
        return
    
    # 4. Profil utilisateur
    print("\n3Ô∏è‚É£ === PROFIL UTILISATEUR ===")
    client.get_profile()
    
    # 5. √âtat initial des fichiers
    print("\n4Ô∏è‚É£ === √âTAT INITIAL DES FICHIERS ===")
    initial_files = client.get_files()
    if initial_files:
        print(f"üìÅ Nombre de fichiers existants: {initial_files.get('count', 0)}")
    
    # 6. Upload du fichier django_translation.po - LOGIQUE CORRIG√âE
    print("\n5Ô∏è‚É£ === UPLOAD DU FICHIER DJANGO_TRANSLATION.PO ===")
    uploaded_file = client.upload_file(django_po_path)
    
    # Nouvelle logique pour g√©rer l'upload
    file_id = None
    
    if uploaded_file is not None:
        print("‚úÖ Upload trait√© avec succ√®s!")
        
        # Essayer de r√©cup√©rer l'ID depuis la r√©ponse
        if isinstance(uploaded_file, dict):
            file_data = uploaded_file.get('data', {})
            file_id = file_data.get('id')
            
            if not file_id:
                # Si pas d'ID dans data, chercher dans la racine
                file_id = uploaded_file.get('id')
        
        # Si on n'a toujours pas d'ID, r√©cup√©rer la liste des fichiers
        if not file_id:
            print("üîç R√©cup√©ration de l'ID via la liste des fichiers...")
            files_list = client.get_files(ordering='-uploaded_at', page_size=1)
            if files_list and files_list.get('results'):
                latest_file = files_list['results'][0]
                file_id = latest_file.get('id')
                print(f"üÜî ID du fichier le plus r√©cent: {file_id}")
        
        if file_id:
            print(f"üÜî ID du fichier √† utiliser: {file_id}")
        else:
            print("‚ö†Ô∏è Impossible de r√©cup√©rer l'ID du fichier, mais continuons les tests g√©n√©raux...")
    else:
        print("‚ùå √âchec de l'upload.")
        print("üîÑ Tentative de r√©cup√©ration du dernier fichier upload√©...")
        
        # Essayer de r√©cup√©rer quand m√™me le dernier fichier
        files_list = client.get_files(ordering='-uploaded_at', page_size=1)
        if files_list and files_list.get('results'):
            latest_file = files_list['results'][0]
            file_id = latest_file.get('id')
            print(f"üÜî Utilisation du fichier le plus r√©cent: {file_id}")
    
    # Continuer les tests si on a un file_id
    if file_id:
        # 7. Surveillance du traitement
        print("\n6Ô∏è‚É£ === SURVEILLANCE DU TRAITEMENT ===")
        processing_success = client.monitor_file_progress(file_id, max_attempts=15, interval=2)
        
        if not processing_success:
            print("‚ö†Ô∏è Le traitement n'est pas termin√©, mais continuons les tests...")
        
        # 8. D√©tails du fichier trait√©
        print("\n7Ô∏è‚É£ === D√âTAILS DU FICHIER TRAIT√â ===")
        file_details = client.get_file_details(file_id)
        
        if file_details:
            data = file_details.get('data', {})
            print(f"üìÑ Nom: {data.get('filename')}")
            print(f"üìä Statut: {data.get('status')}")
            print(f"üî¢ Nombre de cha√Ænes: {data.get('string_count', 0)}")
            print(f"üåê Framework: {data.get('framework')}")
            print(f"üìÖ Date d'upload: {data.get('uploaded_at')}")
        
        # 9. Analyse des cha√Ænes du fichier
        print("\n8Ô∏è‚É£ === ANALYSE DES CHA√éNES ===")
        file_strings = client.get_strings_by_file(file_id, page_size=10)
        
        if file_strings:
            strings_data = file_strings.get('results', [])
            print(f"üî§ Premi√®res cha√Ænes trouv√©es: {len(strings_data)}")
            
            for i, string_data in enumerate(strings_data[:5], 1):
                print(f"\nüî∏ Cha√Æne {i}:")
                print(f"   üóùÔ∏è Cl√©: {string_data.get('key', 'N/A')}")
                print(f"   üìù Texte source: {string_data.get('source_text', 'N/A')[:100]}...")
                print(f"   ‚úÖ Traduite: {string_data.get('is_translated', False)}")
                print(f"   üìç Ligne: {string_data.get('line_number', 'N/A')}")
        
        # 14. URL de t√©l√©chargement
        print("\n1Ô∏è‚É£3Ô∏è‚É£ === URL DE T√âL√âCHARGEMENT ===")
        download_url = client.get_file_download_url(file_id)
    
    # Tests g√©n√©raux (pas besoin de file_id sp√©cifique)
    
    # 10. Statistiques des cha√Ænes
    print("\n9Ô∏è‚É£ === STATISTIQUES DES CHA√éNES ===")
    strings_stats = client.get_strings_statistics()
    
    # 11. Recherche de cha√Ænes sp√©cifiques
    print("\nüîü === RECHERCHE DE CHA√éNES SP√âCIFIQUES ===")
    
    # Rechercher des cha√Ænes communes dans Django
    search_terms = ['login', 'password', 'email', 'user', 'error', 'admin']
    
    for term in search_terms:
        print(f"\nüîç Recherche de '{term}':")
        search_result = client.get_strings(search=term, page_size=3)
        if search_result and search_result.get('results'):
            print(f"   ‚úÖ {len(search_result['results'])} r√©sultat(s) trouv√©(s)")
            for result in search_result['results'][:2]:
                print(f"   üìù {result.get('source_text', '')[:80]}...")
        else:
            print(f"   ‚ùå Aucun r√©sultat pour '{term}'")
    
    # 12. Cha√Ænes non traduites
    print("\n1Ô∏è‚É£1Ô∏è‚É£ === CHA√éNES NON TRADUITES ===")
    untranslated = client.get_strings(is_translated=False, page_size=5)
    if untranslated and untranslated.get('results'):
        print(f"üî¥ {len(untranslated['results'])} cha√Ænes non traduites trouv√©es")
        for string_data in untranslated['results']:
            print(f"   üìù {string_data.get('source_text', '')[:80]}...")
    
    # 13. Cha√Ænes traduites
    print("\n1Ô∏è‚É£2Ô∏è‚É£ === CHA√éNES TRADUITES ===")
    translated = client.get_strings(is_translated=True, page_size=5)
    if translated and translated.get('results'):
        print(f"üü¢ {len(translated['results'])} cha√Ænes traduites trouv√©es")
        for string_data in translated['results']:
            print(f"   üìù {string_data.get('source_text', '')[:80]}...")
    
    # 15. Statistiques finales
    print("\n1Ô∏è‚É£4Ô∏è‚É£ === STATISTIQUES FINALES ===")
    client.get_files_statistics()
    
    print("\n" + "=" * 70)
    print("‚úÖ TEST AVEC DJANGO_TRANSLATION.PO TERMIN√â!")
    print("=" * 70)
    
    return file_id

# Ex√©cution du test
if __name__ == "__main__":
    test_django_translation()